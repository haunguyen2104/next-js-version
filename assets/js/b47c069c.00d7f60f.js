"use strict";(self.webpackChunknext_version=self.webpackChunknext_version||[]).push([[8914],{5559:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>a,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>c,toc:()=>d});var s=n(5893),r=n(1151);const o={description:"API reference for `getStaticProps`. Learn how to use `getStaticProps` to generate static pages with Next.js."},i="getStaticProps",c={id:"next-js/v13.0.0/api-reference/data-fetching/get-static-props",title:"getStaticProps",description:"API reference for `getStaticProps`. Learn how to use `getStaticProps` to generate static pages with Next.js.",source:"@site/docs/next-js/v13.0.0/api-reference/data-fetching/get-static-props.md",sourceDirName:"next-js/v13.0.0/api-reference/data-fetching",slug:"/next-js/v13.0.0/api-reference/data-fetching/get-static-props",permalink:"/next-js/v13.0.0/api-reference/data-fetching/get-static-props",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/next-js/v13.0.0/api-reference/data-fetching/get-static-props.md",tags:[],version:"current",frontMatter:{description:"API reference for `getStaticProps`. Learn how to use `getStaticProps` to generate static pages with Next.js."},sidebar:"tutorialSidebar",previous:{title:"getStaticPaths",permalink:"/next-js/v13.0.0/api-reference/data-fetching/get-static-paths"},next:{title:"Edge Runtime",permalink:"/next-js/v13.0.0/api-reference/edge-runtime"}},a={},d=[{value:"Context parameter",id:"context-parameter",level:2},{value:"getStaticProps return values",id:"getstaticprops-return-values",level:2},{value:"<code>props</code>",id:"props",level:3},{value:"<code>revalidate</code>",id:"revalidate",level:3},{value:"<code>notFound</code>",id:"notfound",level:3},{value:"<code>redirect</code>",id:"redirect",level:3},{value:"Reading files: Use <code>process.cwd()</code>",id:"reading-files-use-processcwd",level:2},{value:"getStaticProps with TypeScript",id:"getstaticprops-with-typescript",level:2},{value:"Related",id:"related",level:2}];function l(e){const t={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.a)(),...e.components},{Details:n}=t;return n||function(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h1,{id:"getstaticprops",children:"getStaticProps"}),"\n",(0,s.jsxs)(n,{children:[(0,s.jsx)("summary",{children:(0,s.jsx)("b",{children:"Version History"})}),(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{children:"Version"}),(0,s.jsx)(t.th,{children:"Changes"})]})}),(0,s.jsxs)(t.tbody,{children:[(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:(0,s.jsx)(t.code,{children:"v12.2.0"})}),(0,s.jsxs)(t.td,{children:[(0,s.jsx)(t.a,{href:"/docs/basic-features/data-fetching/incremental-static-regeneration.md#on-demand-revalidation",children:"On-Demand Incremental Static Regeneration"})," is stable."]})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:(0,s.jsx)(t.code,{children:"v12.1.0"})}),(0,s.jsxs)(t.td,{children:[(0,s.jsx)(t.a,{href:"/docs/basic-features/data-fetching/incremental-static-regeneration.md#on-demand-revalidation",children:"On-Demand Incremental Static Regeneration"})," added (beta)."]})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:(0,s.jsx)(t.code,{children:"v10.0.0"})}),(0,s.jsxs)(t.td,{children:[(0,s.jsx)(t.code,{children:"locale"}),", ",(0,s.jsx)(t.code,{children:"locales"}),", ",(0,s.jsx)(t.code,{children:"defaultLocale"}),", and ",(0,s.jsx)(t.code,{children:"notFound"})," options added."]})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:(0,s.jsx)(t.code,{children:"v10.0.0"})}),(0,s.jsxs)(t.td,{children:[(0,s.jsx)(t.code,{children:"fallback: 'blocking'"})," return option added."]})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:(0,s.jsx)(t.code,{children:"v9.5.0"})}),(0,s.jsxs)(t.td,{children:["Stable ",(0,s.jsx)(t.a,{href:"/docs/basic-features/data-fetching/incremental-static-regeneration.md",children:"Incremental Static Regeneration"})]})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:(0,s.jsx)(t.code,{children:"v9.3.0"})}),(0,s.jsxs)(t.td,{children:[(0,s.jsx)(t.code,{children:"getStaticProps"})," introduced."]})]})]})]})]}),"\n",(0,s.jsxs)(t.p,{children:["Exporting a function called ",(0,s.jsx)(t.code,{children:"getStaticProps"})," will pre-render a page at build time using the props returned from the function:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-jsx",children:"export async function getStaticProps(context) {\n  return {\n    props: {}, // will be passed to the page component as props\n  }\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["You can import modules in top-level scope for use in ",(0,s.jsx)(t.code,{children:"getStaticProps"}),". Imports used will ",(0,s.jsx)(t.strong,{children:"not be bundled for the client-side"}),". This means you can write ",(0,s.jsxs)(t.strong,{children:["server-side code directly in ",(0,s.jsx)(t.code,{children:"getStaticProps"})]}),", including fetching data from your database."]}),"\n",(0,s.jsx)(t.h2,{id:"context-parameter",children:"Context parameter"}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.code,{children:"context"})," parameter is an object containing the following keys:"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"params"})," contains the route parameters for pages using ",(0,s.jsx)(t.a,{href:"/docs/routing/dynamic-routes.md",children:"dynamic routes"}),". For example, if the page name is ",(0,s.jsx)(t.code,{children:"[id].js"})," , then ",(0,s.jsx)(t.code,{children:"params"})," will look like ",(0,s.jsx)(t.code,{children:"{ id: ... }"}),". You should use this together with ",(0,s.jsx)(t.code,{children:"getStaticPaths"}),", which we\u2019ll explain later."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"preview"})," is ",(0,s.jsx)(t.code,{children:"true"})," if the page is in the ",(0,s.jsx)(t.a,{href:"/docs/advanced-features/preview-mode.md",children:"Preview Mode"})," and ",(0,s.jsx)(t.code,{children:"undefined"})," otherwise."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"previewData"})," contains the ",(0,s.jsx)(t.a,{href:"/docs/advanced-features/preview-mode.md",children:"preview"})," data set by ",(0,s.jsx)(t.code,{children:"setPreviewData"}),"."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"locale"})," contains the active locale (if enabled)."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"locales"})," contains all supported locales (if enabled)."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"defaultLocale"})," contains the configured default locale (if enabled)."]}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"getstaticprops-return-values",children:"getStaticProps return values"}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.code,{children:"getStaticProps"})," function should return an object containing either ",(0,s.jsx)(t.code,{children:"props"}),", ",(0,s.jsx)(t.code,{children:"redirect"}),", or ",(0,s.jsx)(t.code,{children:"notFound"})," followed by an ",(0,s.jsx)(t.strong,{children:"optional"})," ",(0,s.jsx)(t.code,{children:"revalidate"})," property."]}),"\n",(0,s.jsx)(t.h3,{id:"props",children:(0,s.jsx)(t.code,{children:"props"})}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.code,{children:"props"})," object is a key-value pair, where each value is received by the page component. It should be a ",(0,s.jsx)(t.a,{href:"https://developer.mozilla.org/en-US/docs/Glossary/Serialization",children:"serializable object"})," so that any props passed, could be serialized with ",(0,s.jsx)(t.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify",children:(0,s.jsx)(t.code,{children:"JSON.stringify"})}),"."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-jsx",children:"export async function getStaticProps(context) {\n  return {\n    props: { message: `Next.js is awesome` }, // will be passed to the page component as props\n  }\n}\n"})}),"\n",(0,s.jsx)(t.h3,{id:"revalidate",children:(0,s.jsx)(t.code,{children:"revalidate"})}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.code,{children:"revalidate"})," property is the amount in seconds after which a page re-generation can occur (defaults to ",(0,s.jsx)(t.code,{children:"false"})," or no revalidation)."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"// This function gets called at build time on server-side.\n// It may be called again, on a serverless function, if\n// revalidation is enabled and a new request comes in\nexport async function getStaticProps() {\n  const res = await fetch('https://.../posts')\n  const posts = await res.json()\n\n  return {\n    props: {\n      posts,\n    },\n    // Next.js will attempt to re-generate the page:\n    // - When a request comes in\n    // - At most once every 10 seconds\n    revalidate: 10, // In seconds\n  }\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Learn more about ",(0,s.jsx)(t.a,{href:"/docs/basic-features/data-fetching/incremental-static-regeneration.md",children:"Incremental Static Regeneration"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["The cache status of a page leveraging ISR can be determined by reading the value of the ",(0,s.jsx)(t.code,{children:"x-nextjs-cache"})," response header. The possible values are the following:"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"MISS"})," - the path is not in the cache (occurs at most once, on the first visit)"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"STALE"})," - the path is in the cache but exceeded the revalidate time so it will be updated in the background"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"HIT"})," - the path is in the cache and has not exceeded the revalidate time"]}),"\n"]}),"\n",(0,s.jsx)(t.h3,{id:"notfound",children:(0,s.jsx)(t.code,{children:"notFound"})}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.code,{children:"notFound"})," boolean allows the page to return a ",(0,s.jsx)(t.code,{children:"404"})," status and ",(0,s.jsx)(t.a,{href:"/docs/advanced-features/custom-error-page.md#404-page",children:"404 Page"}),". With ",(0,s.jsx)(t.code,{children:"notFound: true"}),", the page will return a ",(0,s.jsx)(t.code,{children:"404"})," even if there was a successfully generated page before. This is meant to support use cases like user-generated content getting removed by its author. Note, ",(0,s.jsx)(t.code,{children:"notFound"})," follows the same ",(0,s.jsx)(t.code,{children:"revalidate"})," behavior ",(0,s.jsx)(t.a,{href:"/docs/api-reference/data-fetching/get-static-props.md#revalidate",children:"described here"}),"."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"export async function getStaticProps(context) {\n  const res = await fetch(`https://.../data`)\n  const data = await res.json()\n\n  if (!data) {\n    return {\n      notFound: true,\n    }\n  }\n\n  return {\n    props: { data }, // will be passed to the page component as props\n  }\n}\n"})}),"\n",(0,s.jsxs)(t.blockquote,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Note"}),": ",(0,s.jsx)(t.code,{children:"notFound"})," is not needed for ",(0,s.jsx)(t.a,{href:"/docs/api-reference/data-fetching/get-static-paths#fallback-false",children:(0,s.jsx)(t.code,{children:"fallback: false"})})," mode as only paths returned from ",(0,s.jsx)(t.code,{children:"getStaticPaths"})," will be pre-rendered."]}),"\n"]}),"\n",(0,s.jsx)(t.h3,{id:"redirect",children:(0,s.jsx)(t.code,{children:"redirect"})}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.code,{children:"redirect"})," object allows redirecting to internal or external resources. It should match the shape of ",(0,s.jsx)(t.code,{children:"{ destination: string, permanent: boolean }"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["In some rare cases, you might need to assign a custom status code for older ",(0,s.jsx)(t.code,{children:"HTTP"})," clients to properly redirect. In these cases, you can use the ",(0,s.jsx)(t.code,{children:"statusCode"})," property instead of the ",(0,s.jsx)(t.code,{children:"permanent"})," property, ",(0,s.jsx)(t.strong,{children:"but not both"}),". You can also set ",(0,s.jsx)(t.code,{children:"basePath: false"})," similar to redirects in ",(0,s.jsx)(t.code,{children:"next.config.js"}),"."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"export async function getStaticProps(context) {\n  const res = await fetch(`https://...`)\n  const data = await res.json()\n\n  if (!data) {\n    return {\n      redirect: {\n        destination: '/',\n        permanent: false,\n        // statusCode: 301\n      },\n    }\n  }\n\n  return {\n    props: { data }, // will be passed to the page component as props\n  }\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["If the redirects are known at build-time, they should be added in ",(0,s.jsx)(t.a,{href:"/docs/api-reference/next.config.js/redirects.md",children:(0,s.jsx)(t.code,{children:"next.config.js"})})," instead."]}),"\n",(0,s.jsxs)(t.h2,{id:"reading-files-use-processcwd",children:["Reading files: Use ",(0,s.jsx)(t.code,{children:"process.cwd()"})]}),"\n",(0,s.jsxs)(t.p,{children:["Files can be read directly from the filesystem in ",(0,s.jsx)(t.code,{children:"getStaticProps"}),"."]}),"\n",(0,s.jsx)(t.p,{children:"In order to do so you have to get the full path to a file."}),"\n",(0,s.jsxs)(t.p,{children:["Since Next.js compiles your code into a separate directory you can't use ",(0,s.jsx)(t.code,{children:"__dirname"})," as the path it returns will be different from the pages directory."]}),"\n",(0,s.jsxs)(t.p,{children:["Instead you can use ",(0,s.jsx)(t.code,{children:"process.cwd()"})," which gives you the directory where Next.js is being executed."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-jsx",children:"import { promises as fs } from 'fs'\nimport path from 'path'\n\n// posts will be populated at build time by getStaticProps()\nfunction Blog({ posts }) {\n  return (\n    <ul>\n      {posts.map((post) => (\n        <li>\n          <h3>{post.filename}</h3>\n          <p>{post.content}</p>\n        </li>\n      ))}\n    </ul>\n  )\n}\n\n// This function gets called at build time on server-side.\n// It won't be called on client-side, so you can even do\n// direct database queries.\nexport async function getStaticProps() {\n  const postsDirectory = path.join(process.cwd(), 'posts')\n  const filenames = await fs.readdir(postsDirectory)\n\n  const posts = filenames.map(async (filename) => {\n    const filePath = path.join(postsDirectory, filename)\n    const fileContents = await fs.readFile(filePath, 'utf8')\n\n    // Generally you would parse/transform the contents\n    // For example you can transform markdown to HTML here\n\n    return {\n      filename,\n      content: fileContents,\n    }\n  })\n  // By returning { props: { posts } }, the Blog component\n  // will receive `posts` as a prop at build time\n  return {\n    props: {\n      posts: await Promise.all(posts),\n    },\n  }\n}\n\nexport default Blog\n"})}),"\n",(0,s.jsx)(t.h2,{id:"getstaticprops-with-typescript",children:"getStaticProps with TypeScript"}),"\n",(0,s.jsxs)(t.p,{children:["The type of ",(0,s.jsx)(t.code,{children:"getStaticProps"})," can be specified using ",(0,s.jsx)(t.code,{children:"GetStaticProps"})," from ",(0,s.jsx)(t.code,{children:"next"}),":"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",children:"import { GetStaticProps } from 'next'\n\ntype Post = {\n  author: string\n  content: string\n}\n\nexport const getStaticProps: GetStaticProps<{ posts: Post[] }> = async (\n  context\n) => {\n  const res = await fetch('https://.../posts')\n  const posts: Post[] = await res.json()\n\n  return {\n    props: {\n      posts,\n    },\n  }\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["If you want to get inferred typings for your props, you can use ",(0,s.jsx)(t.code,{children:"InferGetStaticPropsType<typeof getStaticProps>"}),":"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-tsx",children:"import { InferGetStaticPropsType } from 'next'\nimport { GetStaticProps } from 'next'\n\ntype Post = {\n  author: string\n  content: string\n}\n\nexport const getStaticProps: GetStaticProps<{ posts: Post[] }> = async () => {\n  const res = await fetch('https://.../posts')\n  const posts: Post[] = await res.json()\n\n  return {\n    props: {\n      posts,\n    },\n  }\n}\n\nfunction Blog({ posts }: InferGetStaticPropsType<typeof getStaticProps>) {\n  // will resolve posts to type Post[]\n}\n\nexport default Blog\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Implicit typing for ",(0,s.jsx)(t.code,{children:"getStaticProps"})," will also work properly:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-tsx",children:"import { InferGetStaticPropsType } from 'next'\n\ntype Post = {\n  author: string\n  content: string\n}\n\nexport const getStaticProps = async () => {\n  const res = await fetch('https://.../posts')\n  const posts: Post[] = await res.json()\n\n  return {\n    props: {\n      posts,\n    },\n  }\n}\n\nfunction Blog({ posts }: InferGetStaticPropsType<typeof getStaticProps>) {\n  // will resolve posts to type Post[]\n}\n\nexport default Blog\n"})}),"\n",(0,s.jsx)(t.h2,{id:"related",children:"Related"}),"\n",(0,s.jsx)(t.p,{children:"For more information on what to do next, we recommend the following sections:"}),"\n",(0,s.jsx)("div",{class:"card",children:(0,s.jsxs)("a",{href:"/docs/basic-features/data-fetching/overview.md",children:[(0,s.jsx)("b",{children:"Data Fetching:"}),(0,s.jsx)("small",{children:"Learn more about data fetching in Next.js."})]})})]})}function h(e={}){const{wrapper:t}={...(0,r.a)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},1151:(e,t,n)=>{n.d(t,{Z:()=>c,a:()=>i});var s=n(7294);const r={},o=s.createContext(r);function i(e){const t=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),s.createElement(o.Provider,{value:t},e.children)}}}]);